---
title: "Parallel computing with runoutSIM"
author: "Jason Goetz"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Parallel computing with runoutSIM}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

[`runoptGPP`](https://github.com/jngtz/runoptGPP) is an R package developed for optimizing the random walk (path/dispersion) and PCM (distance) components of mass-movement runout simulations. It provides functions to perform grid search optimization, evaluate performance metrics, and visualize results.

The optimization follows a two-stage approach:

1.  **Optimize random walk model** for best path simulation.

2.  **Optimize PCM model** for best runout distance using the previously optimized path.

Performance is evaluated using AUROC for path accuracy, and relative runout distance error for distance modeling (see [Goetz et al. 2021, NHESS](https://nhess.copernicus.org/articles/21/2543/2021/)).

This vignette covers:

-   Installing `runoptGPP` from GitHub

-   Finding optimal global parameters using grid search

-   Performing spatial cross-validation to assess model sensitivity

# Installing `runoptGPP`

`runoptGPP` is not currently available on CRAN. To install it directly from GitHub, use:

```{r, eval=FALSE}
remotes::install_github("jngtz/runoptGPP")
```

# Loading packages and input data

We begin by loading the required packages, a digital elevation model (DEM), and vector data for debris-flow source points and mapped runout polygons.

```{r, message=FALSE, results='hide', fig.show='hold', fig.height=7, fig.width = 5, fig.align='center'}
# load packages
library(runoutSim)
library(runoptGPP)
library(terra)
library(sf)

# Load digital elevation model (DEM)
dem <- rast("C:/GitProjects/runoutSIM/Dev/Data/elev_fillsinks_WangLiu.tif")

# Compute hillshade for visualization 
slope <- terrain(dem, "slope", unit="radians")
aspect <- terrain(dem, "aspect", unit="radians")
hill <- round(shade(slope, aspect, 40, 270, normalize = TRUE))

# Load debris flow runout source points and polygons
source_points <- st_read("C:/GitProjects/runoutSIM/Dev/Data/debris_flow_source_points.shp")
runout_polygons <- st_read("C:/GitProjects/runoutSIM/Dev/Data/debris_flow_runout_polygons.shp")

# Plot input data
plot(hill, col=grey(150:255/255), legend=FALSE,
     mar=c(2,2,1,4))
plot(dem, col=viridis::mako(100), alpha = .5, add = TRUE)
plot(st_geometry(runout_polygons), add = TRUE)
```

# 

# Optimizing Random Walk Parameters

## Step 1: Define the parameter search space

To simulate runout *paths*, we define a parameter grid for:

-   `rwexp`: divergence exponent (controls spread)

-   `rwper`: persistence factor (controls directionality)

-   `rwslp`: slope threshold (affects frictional resistance)

```{r}
steps <- 5
rwexp_vec <- seq(1.3, 3, len=steps) # Expondent of divergence
rwper_vec <- seq(1.5, 2, len=steps) # Persistence factor
rwslp_vec <- seq(20, 40, len=steps) # Slope threshold

rwexp_vec
rwper_vec
rwslp_vec
```

## Step 2: Parallelize the grid search

We use the `foreach` and `doParallel` packages to speed up model runs by distributing them across multiple CPU cores. For each mapped runout polygon, all combinations of parameters are evaluated using the `rwGridsearch()` function.

```{r, fig.show='hold', fig.height=4, fig.width = 7, fig.align='center'}
library(foreach)
library(raster)
polyid_vec <- 1:nrow(source_points)

n_cores <- parallel::detectCores() -2
cl <- parallel::makeCluster(n_cores)
doParallel::registerDoParallel(cl)

#Coerce dem to raster() dem.
dem <- raster(dem)

rw_gridsearch_multi  <-
  foreach(poly_id=polyid_vec, .packages=c('terra','raster', 'ROCR', 'sf', 'runoptGPP', 'runoutSim')) %dopar% {
    
    rwGridsearch(dem, slide_plys = runout_polygons, slide_src = source_points,
                 slide_id = poly_id, slp_v = rwslp_vec, ex_v = rwexp_vec, 
                 per_v = rwper_vec, gpp_iter = 1000, buffer_ext = 500, buffer_source = NULL,
                 save_res = FALSE, plot_eval = FALSE)
    
  }

parallel::stopCluster(cl)
```

## Step 3: Get the optimal parameters

We extract the optimal parameters across all runouts by aggregating their performance (here, using the median AUROC).

```{r}
rw_opt <- rwGetOpt(rw_gridsearch_multi, 
                   measure = median)
rw_opt
```

# Optimizing PCM Parameters (Runout Distance)

## Step 1: Define the parameter space

We now define grid vectors for:

-   `pcmmd`: mass-to-drag ratio (affects how far material travels)
-   `pcmmu`: sliding friction coefficient

```{r}
# Define PCM model grid seach space
pcmmd_vec <- seq(20, 150, by=5) # mass-to-drag ratio (m)
pcmmu_vec <- seq(0.04, 0.6, by=0.01) # sliding friction coefficient 

pcmmd_vec
```

## Step 2: Run PCM grid search in parallel

Here, we re-use parallelization to optimize the PCM model using the previously selected random walk parameters. Each runout is simulated independently.

```{r}
# Run using parallelization
cl <- parallel::makeCluster(4)
doParallel::registerDoParallel(cl)

pcm_gridsearch_multi <-
  foreach(poly_id=polyid_vec, .packages=c('terra','raster', 'ROCR', 'sf', 'runoptGPP', 'runoutSim')) %dopar% {
    
    pcmGridsearch(dem,
                  slide_plys = runout_polygons, slide_src = source_points, 
                  slide_id = poly_id, rw_slp = 40, rw_ex = 3, rw_per = 1.9, 
                  pcm_mu_v = pcmmu_vec, pcm_md_v = 40,
                  gpp_iter = 1000,
                  buffer_ext = NULL, buffer_source = NULL,
                  predict_threshold = 0.5, save_res = FALSE)
  }

parallel::stopCluster(cl)
```

## Step 3: Extract optimal PCM parameters

We find the PCM parameter set that results in the **lowest median relative error** across all simulated runouts. This gives us a regionally optimized distance model.

```{r}
pcmGetOpt(pcm_gridsearch_multi, 
          performance = "relerr", 
          measure = "median", 
          plot_opt = TRUE)
```

# Spatial Cross-Validation of Parameters

To evaluate the sensitivity of our optimal parameters to spatial sampling, we apply **spatial cross-validation** using k-means partitioning from the `sperrorest` package. This simulates training/testing under different spatial configurations.

We run 5-fold cross-validation with 10 repetitions.

```{r}
par(mfrow = c(1,2))
rw_spcv <- rwSPCV(x = rw_gridsearch_multi, slide_plys = runout_polygons,
                  n_folds = 5, repetitions = 10)

freq_rw <- rwPoolSPCV(rw_spcv, plot_freq = TRUE)

pcm_spcv <- pcmSPCV(pcm_gridsearch_multi, slide_plys = runout_polygons,
                    n_folds = 5, repetitions = 10, from_save = FALSE)

freq_pcm <- pcmPoolSPCV(pcm_spcv, plot_freq = TRUE)

freq_rw
freq_pcm
```
