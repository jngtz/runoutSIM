[{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_basic_intro.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"A basic introduction to runoutSIM","text":"runoutSIM package developed regional-scale runout simulations (spatial distribution velocity) using random walks. vignette provides introduction applying runoutSIM regional debris flow simulation using subcatchment upper Maipo river basin, Chile example. vignette, : Load visualize spatial data Simulate runout single multiple source cells Visualize simulation results rasters interactive maps","code":""},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_basic_intro.html","id":"loading-packages-and-reading-spatial-data","dir":"Articles","previous_headings":"","what":"Loading packages and reading spatial data","title":"A basic introduction to runoutSIM","text":"Spatial handling runoutSIM package supported sf (vector data) terra (gridded/raster data) packages. example, load/read 12.5 m spatial resolution DEM, debris flow runout polygons, corresponding source points mapped polygon. also create hillshade model help visualization results. Tip: Currently, package designed work data UTM coordinate reference system (CRS). need project data local UTM CRS work.","code":"# load packages library(runoutSIM) library(terra) #> Warning: package 'terra' was built under R version 4.4.3 #> terra 1.8.54 library(sf) #> Warning: package 'sf' was built under R version 4.4.3 #> Linking to GEOS 3.13.0, GDAL 3.10.1, PROJ 9.5.1; sf_use_s2() is TRUE  # Load digital elevation model (DEM) dem <- rast(\"C:/GitProjects/runoutSIM/Data/elev_fillsinks_WangLiu.tif\")  # Compute hillshade for visualization  slope <- terrain(dem, \"slope\", unit=\"radians\") aspect <- terrain(dem, \"aspect\", unit=\"radians\") hill <- shade(slope, aspect, 40, 270)  # Load debris flow runout source points and polygons source_points <- st_read(\"C:/GitProjects/runoutSIM/Data/debris_flow_source_points.shp\") #> Reading layer `debris_flow_source_points' from data source  #>   `C:\\GitProjects\\runoutSIM\\Data\\debris_flow_source_points.shp'  #>   using driver `ESRI Shapefile' #> Simple feature collection with 73 features and 1 field #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 389175.6 ymin: 6293926 xmax: 398788.6 ymax: 6327439 #> Projected CRS: WGS 84 / UTM zone 19S runout_polygons <- st_read(\"C:/GitProjects/runoutSIM/Data/debris_flow_runout_polygons.shp\") #> Reading layer `debris_flow_runout_polygons' from data source  #>   `C:\\GitProjects\\runoutSIM\\Data\\debris_flow_runout_polygons.shp'  #>   using driver `ESRI Shapefile' #> Simple feature collection with 73 features and 1 field #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 389139.1 ymin: 6293864 xmax: 398852.9 ymax: 6327455 #> Projected CRS: WGS 84 / UTM zone 19S  # Load basin boundary bnd_catchment <- st_read(\"C:/GitProjects/runoutSIM/Data/basin_rio_olivares.shp\") #> Reading layer `basin_rio_olivares' from data source  #>   `C:\\GitProjects\\runoutSIM\\Data\\basin_rio_olivares.shp' using driver `ESRI Shapefile' #> Simple feature collection with 1 feature and 15 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 386042.8 ymin: 6293348 xmax: 404405.3 ymax: 6331286 #> Projected CRS: WGS 84 / UTM zone 19S"},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_basic_intro.html","id":"creating-interactive-maps","dir":"Articles","previous_headings":"","what":"Creating interactive maps","title":"A basic introduction to runoutSIM","text":"Using leafmap() function, can quickly create interactive leaflet map viewing data. use %>% operator pipe together multiple leafmap() calls create combined leaflet map multiple layers. Tip: leafmap() option interactively query raster values mouse hover. option turned default, can result considerable increase file size leaflet widget (e.g. exported sharing). recommended add_image_query = FALSE saving / exporting leaflet map.","code":"map <- leafmap(bnd_catchment, color = '#f7f9f9', fill_color = '#FF000000', weight = 4) %>%     leafmap(runout_polygons) %>%     leafmap(source_points, color = '#e74c3c') %>%     leafmap(hill, palette = grey(0:100/100), opacity = 1, add_legend = FALSE,              add_image_query = FALSE) %>%     leafmap(dem, palette = viridis::mako(10), opacity = 0.6, add_image_query = FALSE) map"},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_basic_intro.html","id":"simulate-runout-from-a-source-cell","dir":"Articles","previous_headings":"","what":"Simulate runout from a source cell","title":"A basic introduction to runoutSIM","text":"Runout paths simulated individual source cells, defined x, y coordinates. example, simulating runout single source cell defined source point (vector data), use sf::st_coordinates() extract x, y values. Now coordinates, can run random walk runout simulations using runoutSim(). : mu md sliding friction coefficient mass--drag parameters two-parameter friction model controlling runout distance slp_thresh, exp_div, per_fct parameters controlling dispersion random walks walks number random walk iterations runoutSim() returns list containing: cell number DEM indicating location source cell Traverse frequencies grid cell Maximum velocities (m/s) grid cell values stored cell numbers (e.g., $all_indices). Although calculated , prob_connect provides probability source cell connected feature interest.","code":"# Select a single debris flow and source point for the example runout_polygon <- runout_polygons[31,]  # Get corresponding source point source_point  <- st_filter(st_as_sf(source_points), st_as_sf(runout_polygon))  # Get coordinates of source point source_crds <- st_coordinates(source_point) print(source_crds) #>             X       Y #> [1,] 395698.1 6307421 sim_paths = runoutSim(dem = dem,                        xy = source_crds,                        mu = 0.08,                        md = 140,                        slp_thresh = 35,                        exp_div = 2.5,                        per_fct = 1.95,                        walks = 1000)  # plot structure of sim_paths str(sim_paths) #> List of 4 #>  $ start_cell    : num 2803625 #>  $ cell_trav_freq: 'table' int [1:1994(1d)] 3 2 3 11 8 5 3 30 31 24 ... #>   ..- attr(*, \"dimnames\")=List of 1 #>   .. ..$ all_indices: chr [1:1994] \"2774166\" \"2774167\" \"2775633\" \"2775634\" ... #>  $ cell_max_vel  : num [1:1994] 15.2 16.5 11.4 14.3 16 ... #>  $ prob_connect  : NULL"},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_basic_intro.html","id":"converting-results-to-a-raster","dir":"Articles","previous_headings":"Simulate runout from a source cell","what":"Converting results to a raster","title":"A basic introduction to runoutSIM","text":"visualize results, convert output runoutSim() raster.  walksToRaster(), use method = \"freq\" return traverse frequencies. can also return traverse (ECDF) probabilities using method = \"cdf_prob\". use velocityToRaster() get raster velocity values (m/s).","code":"## Convert paths to raster with cell transition frequencies paths_raster <- walksToRaster(sim_paths, dem, method = \"freq\")  # Plot results paths_raster <- crop(paths_raster, ext(runout_polygon)+500) plot(crop(hill, ext(runout_polygon)+500), col=grey(0:100/100), legend=FALSE,      mar=c(2,2,1,4), main = \"Runout traverse frequency\") plot(paths_raster, legend = T, alpha = 0.5, add = TRUE) plot(st_geometry(runout_polygon), add = TRUE) plot(source_point, add = TRUE) ## Convert paths to raster with max. velocities vel_raster <- velocityToRaster(sim_paths, dem)  # Plot results vel_raster <- crop(vel_raster, ext(runout_polygon)+500) plot(crop(hill, ext(runout_polygon)+500), col=grey(0:100/100), legend=FALSE,      mar=c(2,2,1,4), main = \"Runout velocity\") plot(vel_raster, col = map.pal('plasma'), legend = TRUE, alpha = 0.5, add = TRUE) plot(st_geometry(runout_polygon), add = TRUE) plot(source_point, add = TRUE)"},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_basic_intro.html","id":"computing-connectivity-probability","dir":"Articles","previous_headings":"Simulate runout from a source cell","what":"Computing connectivity probability","title":"A basic introduction to runoutSIM","text":"runoutSim() function also allows us calculate connectivity probability source cell feature interest - .e. proportion walks intersect feature given source cell. example, determine connectivity probability simulated debris flow river channel. Using makeConnFeature() function, create matrix indicating value 1 cells contain river channel. Now connectivity feature, can re-run runoutSim() additional parameter options: source_connect = TRUE allowing calculate connectivity probability connect_feature = feature_mask.","code":"# Load river channel polygon (vector) river_channel <- st_read(\"C:/GitProjects/runoutSIM/Data/river_channel.shp\") #> Reading layer `river_channel' from data source  #>   `C:\\GitProjects\\runoutSIM\\Data\\river_channel.shp' using driver `ESRI Shapefile' #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 393504.8 ymin: 6293330 xmax: 396806.5 ymax: 6328149 #> Projected CRS: WGS 84 / UTM zone 19S  # Create a connectivity feature for runoutSim that matches the input DEM feature_mask <- makeConnFeature(river_channel, dem) sim_paths = runoutSim(dem = dem,                        xy = source_crds,                        mu = 0.08,                        md = 140,                        slp_thresh = 35,                        exp_div = 2.5,                        per_fct = 1.95,                        walks = 1000,                       source_connect = TRUE,                       connect_feature = feature_mask)  # Plot structure of sim_paths str(sim_paths) #> List of 4 #>  $ start_cell    : num 2803625 #>  $ cell_trav_freq: 'table' int [1:2009(1d)] 3 3 20 14 6 1 41 41 33 20 ... #>   ..- attr(*, \"dimnames\")=List of 1 #>   .. ..$ all_indices: chr [1:2009] \"2774166\" \"2775633\" \"2775634\" \"2775635\" ... #>  $ cell_max_vel  : num [1:2009] 15 11.7 13.9 16.3 16.7 ... #>  $ prob_connect  : num 0.883  # Get connectivity probability sim_paths$prob_connect #> [1] 0.883  tp_raster <- walksToRaster(sim_paths, dem, method = \"cdf_prob\") conn_raster <- connToRaster(sim_paths, dem)  # Crop results tp_crop <- crop(tp_raster, ext(runout_polygon)+ 500) conn_crop <- crop(conn_raster, ext(runout_polygon)+ 500)  # Plot results par(mfrow = c(2,1)) plot(crop(hill, ext(runout_polygon)+500), col=grey(0:100/100), legend=FALSE,      mar=c(2,2,1,4), main = \"Traverse prob.\") plot(st_geometry(river_channel), col = \"lightblue\", add = TRUE) plot(tp_crop, legend = TRUE, alpha = 0.5, add = TRUE) plot(st_geometry(runout_polygon), add = TRUE) plot(source_point, add = TRUE)   plot(crop(hill, ext(runout_polygon)+500), col=grey(0:100/100), legend=FALSE,      mar=c(2,2,1,4), main = \"Connectivity prob.\") plot(st_geometry(river_channel), col = \"lightblue\", add = TRUE) plot(conn_crop, legend = TRUE, alpha = 0.5, add = TRUE) plot(st_geometry(runout_polygon), add = TRUE) plot(source_point, add = TRUE)"},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_basic_intro.html","id":"simulate-runout-from-multiple-sources","dir":"Articles","previous_headings":"","what":"Simulate runout from multiple-sources","title":"A basic introduction to runoutSIM","text":"simulate runout multiple source cell locations, run runoutSim() iteratively, changing xy coordinates iteration. create list xy coordinates source points (vector), use makeSourceList() function. can now convert list multiple random walks different source cells raster data using walksToRaster() velocityToRaster().  can also view results interactive leaflet map.","code":"# Get coordinates of source points to create a source list object source_l <- makeSourceList(source_points)  # Perform random walk simulation for each source point sim_runs <- list()  for(i in 1:length(source_l)){      sim_runs[[i]] <- runoutSim(dem = dem, xy = source_l[[i]],                                mu = 0.08,                                md = 40,                                slp_thresh = 40,                                exp_div = 3,                                per_fct = 1.9,                                walks = 1000) } # Coerce results to a raster trav_freq <- walksToRaster(sim_runs, method = \"freq\", dem) vel_ms <- velocityToRaster(sim_runs, dem, method = \"max\") trav_prob <- walksToRaster(sim_runs, method = \"max_cdf_prob\", dem)   # Plot random walks from mulitple source cells par(mfrow = c(1,3)) plot(hill, col=grey(0:100/100), legend=FALSE, mar=c(2,2,1,4),       main = \"Traverse frequency\") plot(trav_freq, add = TRUE, alpha = 0.7)  plot(hill, col=grey(0:100/100), legend=FALSE, mar=c(2,2,1,4),       main = \"Traverse probability (max.)\") plot(trav_prob, add = TRUE, alpha = 0.7)  plot(hill, col=grey(0:100/100), legend=FALSE, mar=c(2,2,1,4),       main = \"Velocity (m/s)\") plot(vel_ms, col = map.pal(\"plasma\"), add = TRUE, alpha = 0.7) # Create interactive leaflet map sim_map <-    # Debris flow observations   leafmap(runout_polygons, opacity = 0.3, label = \"Runout polygons\") %>%   leafmap(source_points, color = '#e74c3c', label = \"Source points\") %>%   # Terrain data   leafmap(hill, palette = grey(0:100/100), opacity = 1, add_legend = FALSE,              add_image_query = FALSE, label = \"Hillshade\") %>%   leafmap(dem, palette = viridis::mako(10), opacity = 0.6,            add_image_query = FALSE, label = \"DEM\") %>%   # Modelling results   leafmap(trav_prob,  palette = viridis::viridis(10, direction = -1),            label = \"Traverse prob\", add_image_query = FALSE) %>%   leafmap(vel_ms,  palette = viridis::plasma(10, direction = -1),           label = \"Velocity\", add_image_query = FALSE)  # Start with mapped zoomed in sim_map <- leaflet::setView(sim_map, lng = -70.13694, lat = -33.3703, zoom = 13)   # Hide layers sim_map <- leaflet::hideGroup(sim_map, c(\"Velocity\", \"Source points\", \"DEM\", \"Hillshade\"))  sim_map"},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_optimize_w_runoptGPP.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Grid search optimization of runoutSIM with runoptGPP","text":"runoptGPP R package developed optimizing random walk (path/dispersion) PCM (distance) components mass-movement runout simulations. provides functions perform grid search optimization, evaluate performance metrics, visualize results - support runoutSIM. optimization follows two-stage approach: Optimize random walk model best path simulation. Optimize PCM model best runout distance using previously optimized path. Performance evaluated using AUROC path accuracy, relative runout distance error distance modeling (see Goetz et al. 2021, NHESS). vignette covers: Installing runoptGPP GitHub Finding optimal global parameters using grid search Performing spatial cross-validation assess model sensitivity","code":""},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_optimize_w_runoptGPP.html","id":"installing-runoptgpp","dir":"Articles","previous_headings":"","what":"Installing runoptGPP","title":"Grid search optimization of runoutSIM with runoptGPP","text":"runoptGPP currently available CRAN. install directly GitHub, use:","code":"remotes::install_github(\"jngtz/runoptGPP\")"},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_optimize_w_runoptGPP.html","id":"loading-packages-and-input-data","dir":"Articles","previous_headings":"","what":"Loading packages and input data","title":"Grid search optimization of runoutSIM with runoptGPP","text":"begin loading required packages, digital elevation model (DEM), vector data debris-flow source points mapped runout polygons.","code":"# load packages library(runoutSIM) library(runoptGPP) library(terra) #> Warning: package 'terra' was built under R version 4.4.3 library(sf) #> Warning: package 'sf' was built under R version 4.4.3  # Load digital elevation model (DEM) dem <- rast(\"Data/elev_fillsinks_WangLiu.tif\")  # Compute hillshade for visualization  slope <- terrain(dem, \"slope\", unit=\"radians\") aspect <- terrain(dem, \"aspect\", unit=\"radians\") hill <- round(shade(slope, aspect, 40, 270, normalize = TRUE))  # Load debris flow runout source points and polygons source_points <- st_read(\"Data/debris_flow_source_points.shp\") runout_polygons <- st_read(\"Data/debris_flow_runout_polygons.shp\")  # Plot input data plot(hill, col=grey(150:255/255), legend=FALSE,      mar=c(2,2,1,4)) plot(dem, col=viridis::mako(100), alpha = .5, add = TRUE) plot(st_geometry(runout_polygons), add = TRUE)"},{"path":[]},{"path":[]},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_optimize_w_runoptGPP.html","id":"step-1-define-the-parameter-search-space","dir":"Articles","previous_headings":"Optimizing Random Walk Parameters","what":"Step 1: Define the parameter search space","title":"Grid search optimization of runoutSIM with runoptGPP","text":"first stage optimization, set vectors define grid search space random walk runout path model component. exhaustive list parameters tested. simulate runout paths, define parameter grid : rwexp: divergence exponent (controls spread) rwper: persistence factor (controls directionality) rwslp: slope threshold (affects frictional resistance)","code":"steps <- 5 rwexp_vec <- seq(1.3, 3, len=steps) # Expondent of divergence rwper_vec <- seq(1.5, 2, len=steps) # Persistence factor rwslp_vec <- seq(20, 40, len=steps) # Slope threshold  rwexp_vec #> [1] 1.300 1.725 2.150 2.575 3.000 rwper_vec #> [1] 1.500 1.625 1.750 1.875 2.000 rwslp_vec #> [1] 20 25 30 35 40"},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_optimize_w_runoptGPP.html","id":"step-2-parallelize-the-grid-search","dir":"Articles","previous_headings":"Optimizing Random Walk Parameters","what":"Step 2: Parallelize the grid search","title":"Grid search optimization of runoutSIM with runoptGPP","text":"use foreach doParallel packages speed model runs distributing across multiple CPU cores. mapped runout polygon, combinations parameters evaluated using rwGridsearch() function. Depending number runout events grid search space size, computation can take time. rwGridsearch function option save_res = TRUE allows us save grid search results runout individually. useful case processing fails since avoids need re-run grid search runout events. example creating limited grid search space (.e. 444 possible parameter combinations) reduce computational time.","code":"library(foreach) library(raster) polyid_vec <- 1:nrow(source_points)  n_cores <- parallel::detectCores() -2 cl <- parallel::makeCluster(n_cores) doParallel::registerDoParallel(cl)  #Coerce dem to raster() dem. dem <- raster(dem)  rw_gridsearch_multi  <-   foreach(poly_id=polyid_vec, .packages=c('terra','raster', 'ROCR', 'sf', 'runoptGPP', 'runoutSIM')) %dopar% {          rwGridsearch(dem, slide_plys = runout_polygons, slide_src = source_points,                  slide_id = poly_id, slp_v = rwslp_vec, ex_v = rwexp_vec,                   per_v = rwper_vec, gpp_iter = 1000, buffer_ext = 500, buffer_source = NULL,                  save_res = TRUE, plot_eval = FALSE)        }  parallel::stopCluster(cl)"},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_optimize_w_runoptGPP.html","id":"step-3-get-the-optimal-parameters","dir":"Articles","previous_headings":"Optimizing Random Walk Parameters","what":"Step 3: Get the optimal parameters","title":"Grid search optimization of runoutSIM with runoptGPP","text":"extract optimal parameters across runouts aggregating performance (, using median AUROC).","code":"rw_opt <- rwGetOpt(rw_gridsearch_multi,                     measure = median) rw_opt #>   rw_slp_opt rw_exp_opt rw_per_opt  rw_auroc #> 1         40          3      1.875 0.8748927"},{"path":[]},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_optimize_w_runoptGPP.html","id":"step-1-define-the-parameter-space","dir":"Articles","previous_headings":"Optimizing PCM Parameters (Runout Distance)","what":"Step 1: Define the parameter space","title":"Grid search optimization of runoutSIM with runoptGPP","text":"now define grid vectors : pcmmd: mass--drag ratio (affects far material travels) pcmmu: sliding friction coefficient example creating limited grid search space (.e. 20*10 possible parameter combinations) reduce computational time.","code":"# Define PCM model grid seach space pcmmd_vec <- seq(20, 140, by=20) # mass-to-drag ratio (m) pcmmu_vec <- seq(0.01, 0.1, by=0.01) # sliding friction coefficient   pcmmd_vec #> [1]  20  40  60  80 100 120 140"},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_optimize_w_runoptGPP.html","id":"step-2-run-pcm-grid-search-in-parallel","dir":"Articles","previous_headings":"Optimizing PCM Parameters (Runout Distance)","what":"Step 2: Run PCM grid search in parallel","title":"Grid search optimization of runoutSIM with runoptGPP","text":", re-use parallelization optimize PCM model using previously selected random walk parameters. runout simulated independently.","code":"# Run using parallelization cl <- parallel::detectCores() -2 doParallel::registerDoParallel(cl)  pcm_gridsearch_multi <-   foreach(poly_id=polyid_vec, .packages=c('terra','raster', 'ROCR', 'sf', 'runoptGPP', 'runoutSIM')) %dopar% {          pcmGridsearch(dem,                   slide_plys = runout_polygons, slide_src = source_points,                    slide_id = poly_id, rw_slp = 40, rw_ex = 3, rw_per = 1.9,                    pcm_mu_v = pcmmu_vec, pcm_md_v = pcmmd_vec,                   gpp_iter = 1000,                   buffer_ext = NULL, buffer_source = NULL,                   predict_threshold = 0.5, save_res = FALSE)   }  parallel::stopCluster(cl)"},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_optimize_w_runoptGPP.html","id":"step-3-extract-optimal-pcm-parameters","dir":"Articles","previous_headings":"Optimizing PCM Parameters (Runout Distance)","what":"Step 3: Extract optimal PCM parameters","title":"Grid search optimization of runoutSIM with runoptGPP","text":"find PCM parameter set results lowest median relative error across simulated runouts. gives us regionally optimized distance model. median model performances across grid search space can visualized using plot_opt=TRUE.","code":"pcmGetOpt(pcm_gridsearch_multi,            performance = \"relerr\",            measure = \"median\",            plot_opt = TRUE) #>   pcm_mu pcm_md median_relerr median_auroc #> 1   0.04     40    0.03576527    0.9042586"},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_optimize_w_runoptGPP.html","id":"spatial-cross-validation-of-parameters","dir":"Articles","previous_headings":"","what":"Spatial Cross-Validation of Parameters","title":"Grid search optimization of runoutSIM with runoptGPP","text":"evaluate sensitivity optimal parameters spatial sampling, apply spatial cross-validation using k-means partitioning sperrorest package. simulates training/testing different spatial configurations. run 5-fold cross-validation 10 repetitions using results random walk PCM grid searches.","code":"par(mfrow = c(1,2)) rw_spcv <- rwSPCV(x = rw_gridsearch_multi, slide_plys = runout_polygons,                   n_folds = 5, repetitions = 10)  freq_rw <- rwPoolSPCV(rw_spcv, plot_freq = TRUE)  pcm_spcv <- pcmSPCV(pcm_gridsearch_multi, slide_plys = runout_polygons,                     n_folds = 5, repetitions = 10, from_save = FALSE)  freq_pcm <- pcmPoolSPCV(pcm_spcv, plot_freq = TRUE)  freq_rw #>   slp   per exp freq rel_freq median_auroc   iqr_auroc #> 1  40 1.500   3    9       18    0.8843889 0.020861264 #> 2  40 1.625   3    7       14    0.8215202 0.080693418 #> 3  40 1.750   3    7       14    0.9083694 0.005970888 #> 4  40 1.875   3   24       48    0.8619509 0.029733802 #> 5  40 2.000   3    3        6    0.8119542 0.000000000 freq_pcm #>     mu  md freq rel_freq    rel_err  iqr_relerr #> 1 0.04  40   35       70 0.05290689 0.049399707 #> 2 0.05  40    9       18 0.03205946 0.004627829 #> 3 0.07  40    3        6 0.07844790 0.000000000 #> 4 0.09 100    3        6 0.04196954 0.000000000"},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_parallelization.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Parallel computing with runoutSIM","text":"vignette demonstrates use parallel computing speed random walk runout simulations multiple source cells using runoutSIM package. ’ll run example works Windows machines, using base R’s parallel package PSOCK clusters. vignette show : Prepare source data parallel processing Use PSOCK clusters distribute simulations across multiple cores Efficiently simulate runout multiple sources using runoutSIM","code":""},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_parallelization.html","id":"loading-packages-and-sample-debris-flow-data","dir":"Articles","previous_headings":"","what":"Loading packages and sample debris flow data","title":"Parallel computing with runoutSIM","text":"’ll begin loading required packages reading digital elevation model (DEM) debris flow source points.","code":"# load packages library(runoutSIM) library(terra) #> Warning: package 'terra' was built under R version 4.4.3 #> terra 1.8.54 library(sf) #> Warning: package 'sf' was built under R version 4.4.3 #> Linking to GEOS 3.13.0, GDAL 3.10.1, PROJ 9.5.1; sf_use_s2() is TRUE  # Load digital elevation model (DEM) dem <- rast(\"C:/GitProjects/runoutSIM/Data/elev_fillsinks_WangLiu.tif\")  # Compute hillshade for visualization  slope <- terrain(dem, \"slope\", unit=\"radians\") aspect <- terrain(dem, \"aspect\", unit=\"radians\") hill <- round(shade(slope, aspect, 40, 270, normalize = TRUE))  # Load debris flow runout source points and polygons source_points <- st_read(\"C:/GitProjects/runoutSIM/Data/debris_flow_source_points.shp\") #> Reading layer `debris_flow_source_points' from data source  #>   `C:\\GitProjects\\runoutSIM\\Data\\debris_flow_source_points.shp'  #>   using driver `ESRI Shapefile' #> Simple feature collection with 73 features and 1 field #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 389175.6 ymin: 6293926 xmax: 398788.6 ymax: 6327439 #> Projected CRS: WGS 84 / UTM zone 19S runout_polygons <- st_read(\"C:/GitProjects/runoutSIM/Data/debris_flow_runout_polygons.shp\") #> Reading layer `debris_flow_runout_polygons' from data source  #>   `C:\\GitProjects\\runoutSIM\\Data\\debris_flow_runout_polygons.shp'  #>   using driver `ESRI Shapefile' #> Simple feature collection with 73 features and 1 field #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 389139.1 ymin: 6293864 xmax: 398852.9 ymax: 6327455 #> Projected CRS: WGS 84 / UTM zone 19S  # Plot input data plot(hill, col=grey(150:255/255), legend=FALSE,      mar=c(2,2,1,4)) plot(dem, col=viridis::mako(10), alpha = .5, add = TRUE) plot(st_geometry(runout_polygons), add = TRUE)  # Get coordinates of source points to create a source list object source_l <- makeSourceList(source_points)"},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_parallelization.html","id":"running-simulations-in-parallel","dir":"Articles","previous_headings":"","what":"Running simulations in parallel","title":"Parallel computing with runoutSIM","text":"now parallelize simulations using parLapply(). , wrap DEM make transferable across cluster nodes, load required libraries worker.","code":"library(parallel)  # Define number of cores to use n_cores <- detectCores() -2  # Pack the DEM so it can be passed over a serialized connection packed_dem <- wrap(dem)  # Create parallel loop cl <- makeCluster(n_cores, type = \"PSOCK\") # Open clusters  # Export the packed DEM to each node clusterExport(cl, varlist = c(\"packed_dem\"))  # Load required packages to each cluster clusterEvalQ(cl, {   library(terra)   library(runoutSIM) })  # Compute multiple runout simulations from source cells multi_sim_runs <- parLapply(cl, source_l, function(x) {      runoutSim(dem = unwrap(packed_dem), xy = x,              mu = 0.08,              md = 40,              slp_thresh = 40,              exp_div = 3,              per_fct = 1.9,              walks = 1000) })   stopCluster(cl)"},{"path":"https://jngtz.github.io/runoutSIM/articles/runoutSIM_parallelization.html","id":"visualize-simulation-results","dir":"Articles","previous_headings":"","what":"Visualize simulation results","title":"Parallel computing with runoutSIM","text":"simulations complete, can convert output list simulation paths raster layers visualization analysis.","code":"# Coerce results to a raster trav_freq <- walksToRaster(multi_sim_runs, method = \"freq\", dem) vel_ms <- velocityToRaster(multi_sim_runs, dem, method = \"max\") trav_prob <- walksToRaster(multi_sim_runs, method = \"max_cdf_prob\", dem)   # Plot random walks from mulitple source cells par(mfrow = c(1,3)) plot(hill, col=grey(150:255/255), legend=FALSE, mar=c(2,2,1,4),       main = \"Traverse frequency\") plot(trav_freq, add = TRUE, alpha = 0.7)  plot(hill, col=grey(150:255/255), legend=FALSE, mar=c(2,2,1,4),       main = \"Traverse probability (max.)\") plot(trav_prob, add = TRUE, alpha = 0.7)  plot(hill, col=grey(150:255/255), legend=FALSE, mar=c(2,2,1,4),       main = \"Velocity (m/s)\") plot(vel_ms, col = map.pal(\"plasma\"), add = TRUE, alpha = 0.7)"},{"path":"https://jngtz.github.io/runoutSIM/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jason Goetz. Author, maintainer. Jia Huang. Contributor.","code":""},{"path":"https://jngtz.github.io/runoutSIM/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Goetz J (2025). runoutSIM: Spatial Random Walk Simulation Landslide Runout Connectivity R. R package version 1.0, https://jngtz.github.io/runoutSIM/, https://github.com/jngtz/runoutSim.","code":"@Manual{,   title = {runoutSIM: Spatial Random Walk Simulation of Landslide Runout and Connectivity in R},   author = {Jason Goetz},   year = {2025},   note = {R package version 1.0, https://jngtz.github.io/runoutSIM/},   url = {https://github.com/jngtz/runoutSim}, }"},{"path":"https://jngtz.github.io/runoutSIM/index.html","id":"runoutsim","dir":"","previous_headings":"","what":"Spatial Random Walk Simulation of Landslide Runout and Connectivity in R","title":"Spatial Random Walk Simulation of Landslide Runout and Connectivity in R","text":"runoutSIM R package developed regional-scale runout simulations using random walks. currently can used estimate spatial extent, velocity (via Perla et al’s two-parameter friction model), connectivity : * Debris flows * Snow avalanches Features * Random walk simulation slope-based transition probabilities * Velocity modeling using Perla et al.’s (1980) friction law * Connectivity analysis assess impact downslope features * Allows easy workflow source area prediction models (e.g., GAM, machine learning) * Interactive mapping leaflet htmlwidgets * Optimized parallel processing support large-scale simulations * Integrated runoptGPP grid search parameter optimization","code":""},{"path":"https://jngtz.github.io/runoutSIM/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Spatial Random Walk Simulation of Landslide Runout and Connectivity in R","text":"can install runoutSIM : ","code":"devtools::install_github(\"jngtz/runoutSIM\") remotes::install_github(\"jngtz/runoutSIM\")"},{"path":"https://jngtz.github.io/runoutSIM/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Spatial Random Walk Simulation of Landslide Runout and Connectivity in R","text":"basic introduction runoutSIM Parallel computing runoutSIM Optimizing runoutSIM parameters runoptGPP","code":""},{"path":"https://jngtz.github.io/runoutSIM/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Spatial Random Walk Simulation of Landslide Runout and Connectivity in R","text":"welcome contributions! Please open issue submit pull request. major changes, start discussing ideas via issue.","code":""},{"path":"https://jngtz.github.io/runoutSIM/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Spatial Random Walk Simulation of Landslide Runout and Connectivity in R","text":"use runoutSIM research, please cite: Goetz, J. (2025). runoutSIM: open-source R package simulating mass movement runout connectivity using random walks. GitHub Repository","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/adjCells.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Adjacent Cell Coordinates — adjCells","title":"Get Adjacent Cell Coordinates — adjCells","text":"Calculates coordinates 8 adjacent cells surrounding given center cell.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/adjCells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Adjacent Cell Coordinates — adjCells","text":"","code":"adjCells(r, xy)"},{"path":"https://jngtz.github.io/runoutSIM/reference/adjCells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Adjacent Cell Coordinates — adjCells","text":"r numeric vector length 2 representing resolution raster x y directions (e.g., c(xres, yres)). xy numeric vector length 2 specifying x y coordinates center cell (e.g., c(x, y)).","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/adjCells.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Adjacent Cell Coordinates — adjCells","text":"matrix 8 rows 2 columns containing coordinates adjacent cells.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/adjCells.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Adjacent Cell Coordinates — adjCells","text":"","code":"adjCells(c(10, 10), c(100, 100))"},{"path":"https://jngtz.github.io/runoutSIM/reference/adjRowCol.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Row/Column Indices of Adjacent Cells — adjRowCol","title":"Get Row/Column Indices of Adjacent Cells — adjRowCol","text":"Computes row column indices 8 adjacent cells surrounding given central cell raster grid.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/adjRowCol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Row/Column Indices of Adjacent Cells — adjRowCol","text":"","code":"adjRowCol(rowcol)"},{"path":"https://jngtz.github.io/runoutSIM/reference/adjRowCol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Row/Column Indices of Adjacent Cells — adjRowCol","text":"rowcol numeric vector length 2 representing row column index center cell.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/adjRowCol.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Row/Column Indices of Adjacent Cells — adjRowCol","text":"matrix 8 rows 2 columns row column indices adjacent cells.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/adjRowCol.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Row/Column Indices of Adjacent Cells — adjRowCol","text":"","code":"adjRowCol(c(10, 10)) #>      [,1] [,2] #> [1,]    9    9 #> [2,]   10    9 #> [3,]   11    9 #> [4,]    9   11 #> [5,]   10   11 #> [6,]   11   11 #> [7,]    9   10 #> [8,]   11   10"},{"path":"https://jngtz.github.io/runoutSIM/reference/cdfProb.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Raster Values to Cumulative Distribution — cdfProb","title":"Convert Raster Values to Cumulative Distribution — cdfProb","text":"Applies empirical cumulative distribution function (ECDF) raster values, returning raster cell reflects percentile rank.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/cdfProb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Raster Values to Cumulative Distribution — cdfProb","text":"","code":"cdfProb(x)"},{"path":"https://jngtz.github.io/runoutSIM/reference/cdfProb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Raster Values to Cumulative Distribution — cdfProb","text":"x vector","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/cdfProb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Raster Values to Cumulative Distribution — cdfProb","text":"vector empirical probabilities","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/cdfProb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Raster Values to Cumulative Distribution — cdfProb","text":"","code":"if (FALSE) { # \\dontrun{ test <- cdfProb(c(1,2,3,4,5)) } # }"},{"path":"https://jngtz.github.io/runoutSIM/reference/connToRaster.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Connectivity Probabilities to Raster — connToRaster","title":"Convert Connectivity Probabilities to Raster — connToRaster","text":"Creates raster source cell assigned probability connecting downstream feature.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/connToRaster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Connectivity Probabilities to Raster — connToRaster","text":"","code":"connToRaster(x, dem)"},{"path":"https://jngtz.github.io/runoutSIM/reference/connToRaster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Connectivity Probabilities to Raster — connToRaster","text":"x list outputs multiple runout simulations, containing start_cell prob_connect. dem SpatRaster (typically DEM used simulation) used define output raster grid.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/connToRaster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Connectivity Probabilities to Raster — connToRaster","text":"SpatRaster probability connectivity assigned source cell.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/connToRaster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Connectivity Probabilities to Raster — connToRaster","text":"","code":"if (FALSE) { # \\dontrun{ # Convert connectivity results to a raster conn_prob <- connToRaster(sim_paths, dem) plot(conn_prob) } # }"},{"path":"https://jngtz.github.io/runoutSIM/reference/elevQuantile.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract DEM elevations for a given quantile within a polygon — elevQuantile","title":"Extract DEM elevations for a given quantile within a polygon — elevQuantile","text":"Identifies masks top bottom quantile elevation values within given polygon overlaying digital elevation model (DEM).","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/elevQuantile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract DEM elevations for a given quantile within a polygon — elevQuantile","text":"","code":"elevQuantile(dem, runout_ply, quant = 0.05, upper = TRUE)"},{"path":"https://jngtz.github.io/runoutSIM/reference/elevQuantile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract DEM elevations for a given quantile within a polygon — elevQuantile","text":"dem SpatRaster object representing digital elevation model (DEM). runout_ply SpatVector polygon (compatible SpatialPolygons* object) defining area extract elevation values. quant numeric value 0 1 indicating proportion (quantile) elevation values extract. Defaults 0.05 (top/bottom 5%). upper Logical. TRUE, function selects highest elevation percentile; FALSE, selects lowest. Defaults TRUE.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/elevQuantile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract DEM elevations for a given quantile within a polygon — elevQuantile","text":"SpatRaster object selected cells marked 1 others set NA.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/elevQuantile.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract DEM elevations for a given quantile within a polygon — elevQuantile","text":"function useful identifying areas extreme elevation within polygon, potential landslide release zones (upper) deposition zones (lower), based percentile thresholds.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/elevQuantile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract DEM elevations for a given quantile within a polygon — elevQuantile","text":"","code":"if (FALSE) { # \\dontrun{ library(terra) dem <- rast(\"dem.tif\") runout_ply <- vect(\"runout_area.shp\") release_zone <- elevQuantile(dem, runout_ply, quant = 0.05, upper = TRUE) } # }"},{"path":"https://jngtz.github.io/runoutSIM/reference/euclideanDistance.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Euclidean Distance Between Two Points — euclideanDistance","title":"Calculate Euclidean Distance Between Two Points — euclideanDistance","text":"Computes Euclidean distance two 2D points.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/euclideanDistance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Euclidean Distance Between Two Points — euclideanDistance","text":"","code":"euclideanDistance(p1, p2)"},{"path":"https://jngtz.github.io/runoutSIM/reference/euclideanDistance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Euclidean Distance Between Two Points — euclideanDistance","text":"p1 numeric vector length 2 representing first point's coordinates (x, y). p2 numeric vector length 2 representing second point's coordinates (x, y).","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/euclideanDistance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Euclidean Distance Between Two Points — euclideanDistance","text":"numeric value representing distance two points.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/euclideanDistance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Euclidean Distance Between Two Points — euclideanDistance","text":"","code":"euclideanDistance(c(0, 0), c(3, 4)) #> [1] 5"},{"path":"https://jngtz.github.io/runoutSIM/reference/leafmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Spatial Data Using Leaflet — leafmap","title":"Plot Spatial Data Using Leaflet — leafmap","text":"Creates interactive leaflet map raster sf vector data, options customize basemaps, styling, popups.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/leafmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Spatial Data Using Leaflet — leafmap","text":"","code":"leafmap(   m = NULL,   data = NULL,   group_layers = NULL,   label = NULL,   opacity = 0.5,   color = \"black\",   fill_color = color,   radius = 3,   weight = 2,   palette = \"viridis\",   basemaps = c(\"Esri.WorldImagery\", \"Esri.WorldTopoMap\"),   add_legend = TRUE,   add_image_query = TRUE )"},{"path":"https://jngtz.github.io/runoutSIM/reference/leafmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Spatial Data Using Leaflet — leafmap","text":"m Optional existing leaflet map object. NULL, new map initialized. data Raster*, terra::SpatRaster, sf object plotted. provided, m interpreted data. group_layers Character vector existing overlay groups. Used maintain group-layer visibility toggles. label character string layer label legend title. NULL, auto-generated object name. opacity Numeric (0–1) layer transparency. Defaults 0.5. color Color used vector geometries (ignored rasters). Defaults \"black\". fill_color Color used fill vector geometries (ignored rasters). Defaults color parameter. radius Numeric size circle markers point geometries. Defaults 3. weight Line border thickness vector geometries. Defaults 2. palette Color palette name used leaflet::colorNumeric() raster coloring. Defaults \"viridis\". categorical values, supply list - e.g.  list(classes = 1, colors = \"#99d2ff\", labels = \"Water\")) basemaps Character vector tile provider names (leaflet::providers) include base layers. Defaults c(\"Esri.WorldImagery\", \"Esri.WorldTopoMap\"). add_legend Logical produce legend . Defaults TRUE. Also controls raster value query appears. add_image_query Logical add mouse hover query raster values. Defaults TRUE.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/leafmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Spatial Data Using Leaflet — leafmap","text":"leaflet map object data layer(s) controls.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/leafmap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot Spatial Data Using Leaflet — leafmap","text":"function designed handle standalone piped usage. first argument raster sf object data NULL, automatically reassigns input appropriately. can visualize raster values color palettes legends, render vector data (points, lines, polygons) informative popups. Raster data projected WGS84 (EPSG:4326) colorized using continuous palette. Vector data supports POINT, LINESTRING, POLYGON geometries. Attributes displayed scrollable popups many fields. function adds scale bars, measurement tools, layer controls. add_image_query can make file size leaflet html widget large e.g. 20x's larger. recommended = FALSE exporting Web Page html widget.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/leafmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Spatial Data Using Leaflet — leafmap","text":"","code":"if (FALSE) { # \\dontrun{ library(leaflet) library(sf) library(raster) # From scratch leafmap(data = st_read(system.file(\"shape/nc.shp\", package = \"sf\")))  # Add to existing map m <- leaflet() leafmap(m, st_read(system.file(\"shape/nc.shp\", package = \"sf\"))) } # }"},{"path":"https://jngtz.github.io/runoutSIM/reference/makeConnFeature.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Connectivity Feature Mask — makeConnFeature","title":"Create Connectivity Feature Mask — makeConnFeature","text":"Converts spatial feature (e.g., polygon sf object) binary matrix mask aligned reference DEM used runout simulations.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/makeConnFeature.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Connectivity Feature Mask — makeConnFeature","text":"","code":"makeConnFeature(x, y)"},{"path":"https://jngtz.github.io/runoutSIM/reference/makeConnFeature.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Connectivity Feature Mask — makeConnFeature","text":"x sf object representing feature interest (e.g., polygon). y SpatRaster (e.g., DEM) used reference rasterization.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/makeConnFeature.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Connectivity Feature Mask — makeConnFeature","text":"binary matrix size y, 1 indicating presence feature 0 elsewhere.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/makeConnFeature.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Connectivity Feature Mask — makeConnFeature","text":"","code":"if (FALSE) { # \\dontrun{ feature_mask <- makeConnFeature(my_sf_polygon, my_dem) } # }"},{"path":"https://jngtz.github.io/runoutSIM/reference/makeSourceList.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a list of xy coordinates from terra::xyFromCell coordinates — makeSourceList","title":"Create a list of xy coordinates from terra::xyFromCell coordinates — makeSourceList","text":"Create list xy coordinates terra::xyFromCell coordinates","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/makeSourceList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a list of xy coordinates from terra::xyFromCell coordinates — makeSourceList","text":"","code":"makeSourceList(source_xy)"},{"path":"https://jngtz.github.io/runoutSIM/reference/makeSourceList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a list of xy coordinates from terra::xyFromCell coordinates — makeSourceList","text":"source_xy sf object POINT geometry matrix coordinate pairs (see terra::xyFromCell)","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/makeSourceList.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a list of xy coordinates from terra::xyFromCell coordinates — makeSourceList","text":"","code":"if (FALSE) { # \\dontrun{ source_areas<- rast(\"Dev/Data/classified_w7filter_source_areas.tif\") source_areas <- crop(source_areas, dem) sum(values(source_areas), na.rm = TRUE)  # Find cells where the value is 1 source_cells <- which(values(source_areas) == 1)  source_xy <- xyFromCell(source_areas, source_cells)  source_l <- makeSourceList(source_xy) } # }"},{"path":"https://jngtz.github.io/runoutSIM/reference/pcm.html","id":null,"dir":"Reference","previous_headings":"","what":"PCM Friction Model — pcm","title":"PCM Friction Model — pcm","text":"Implements PCM friction model runout simulation.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/pcm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PCM Friction Model — pcm","text":"","code":"pcm(mu = 0.1, md = 40, v_p = 1, theta_p = 30, theta_i = 20, l = 12.5)"},{"path":"https://jngtz.github.io/runoutSIM/reference/pcm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PCM Friction Model — pcm","text":"mu Numeric. Sliding friction coefficient (default: 0.1). md Numeric. Mass--drag ratio (default: 40). v_p Numeric. Initial velocity (m/s) (default: 1). theta_p Numeric. Slope angle previous grid cell (degrees) (default: 30). theta_i Numeric. Slope angle current grid cell (degrees) (default: 20). l Numeric. Distance grid cells (m) (default: 12.5).","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/pcm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PCM Friction Model — pcm","text":"Numeric. Computed velocity local grid cell. Returns NaN velocity physically possible (e.g., stopping condition).","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/pcm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"PCM Friction Model — pcm","text":"PCM model calculates velocity propagation across terrain grid based friction, slope, mass--drag ratio. includes velocity correction concave slope transitions per Wichmann (2017).","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/pcm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"PCM Friction Model — pcm","text":"Wichmann, V.: Gravitational Process Path (GPP) model (v1.0) – GIS-based simulation framework gravitational processes, Geosci. Model Dev., 10, 3309–3327, https://doi.org/10.5194/gmd-10-3309-2017, 2017. Perla, R., Cheng, T. T., McClung, D. M.: Two–Parameter Model Snow–Avalanche Motion, J. Glaciol., 26, 197–207, https://doi.org/10.3189/S002214300001073X, 1980.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/pcm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PCM Friction Model — pcm","text":"","code":"pcm(mu = 0.1, md = 40, v_p = 2, theta_p = 35, theta_i = 25, l = 12.5) #> [1] 7.913925"},{"path":"https://jngtz.github.io/runoutSIM/reference/rasterCdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Raster Values to Cumulative Distribution — rasterCdf","title":"Convert Raster Values to Cumulative Distribution — rasterCdf","text":"Applies empirical cumulative distribution function (ECDF) raster values, returning raster cell reflects percentile rank.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/rasterCdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Raster Values to Cumulative Distribution — rasterCdf","text":"","code":"rasterCdf(x)"},{"path":"https://jngtz.github.io/runoutSIM/reference/rasterCdf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Raster Values to Cumulative Distribution — rasterCdf","text":"x SpatRaster object (e.g., walksToRaster velocityToRaster).","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/rasterCdf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Raster Values to Cumulative Distribution — rasterCdf","text":"SpatRaster extent resolution values 0 1.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/rasterCdf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Raster Values to Cumulative Distribution — rasterCdf","text":"","code":"if (FALSE) { # \\dontrun{ percentile_raster <- rasterCdf(runout_raster) } # }"},{"path":"https://jngtz.github.io/runoutSIM/reference/runoutSim.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Runout Paths Using Random Walk and PCM Physics — runoutSim","title":"Simulate Runout Paths Using Random Walk and PCM Physics — runoutSim","text":"Simulates runout paths mass movements (e.g., debris flows, snow avalanches) one source points using physically-informed random walk model. path incorporates slope-based directionality, lateral dispersion, energy loss based Perla-Cheng-McClung (PCM) velocity model.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/runoutSim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Runout Paths Using Random Walk and PCM Physics — runoutSim","text":"","code":"runoutSim(   dem,   xy,   mu = 0.1,   md = 40,   int_vel = 1,   slp_thresh = 30,   exp_div = 3,   per_fct = 2,   walks = 100,   source_connect = FALSE,   connect_feature = NULL )"},{"path":"https://jngtz.github.io/runoutSIM/reference/runoutSim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Runout Paths Using Random Walk and PCM Physics — runoutSim","text":"dem SpatRaster. digital elevation model (DEM), ideally sink-filled hydrologically correct. xy Numeric vector matrix. Coordinates one source points (e.g., cbind(x, y)). mu Numeric. Basal friction coefficient used PCM velocity model (default = 0.1). md Numeric. Mass--drag ratio used PCM model control deceleration air drag terrain resistance. int_vel Numeric. Initial velocity PCM model. slp_thresh Numeric. Minimum slope (degrees) required particle movement. Particles stop local slope falls value. exp_div Numeric. Lateral dispersion exponent controlling spread paths away steepest descent. Higher values = less lateral dispersion. per_fct Numeric. Persistence factor controlling strongly particles follow current downslope direction. Values >1 increase directional inertia. walks Integer. Number random walk particles simulate per source point (default = 1000). source_connect Logical. TRUE, particles flagged based whether intersect defined connectivity feature (e.g., stream channel). connect_feature SpatRaster. Optional raster connectivity features created using makeConnFeature(). Required source_connect = TRUE.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/runoutSim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Runout Paths Using Random Walk and PCM Physics — runoutSim","text":"list simulated particle paths. element contains matrix list stepwise information (e.g., coordinates, step index, velocity, slope, connectivity).","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/runoutSim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Runout Paths Using Random Walk and PCM Physics — runoutSim","text":"function simulates gravity-driven runout user-defined source cells. Particle paths evolve random walk process biased terrain slope lateral spread rules. step, PCM velocity model updates particle speed based slope, friction (mu), mass--drag ratio (md). Paths terminate slope falls slp_thresh, particles encounter terrain conditions longer allow continued downhill movement.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/runoutSim.html","id":"pcm-model","dir":"Reference","previous_headings":"","what":"PCM Model","title":"Simulate Runout Paths Using Random Walk and PCM Physics — runoutSim","text":"PCM model (Perla-Cheng-McClung) describes velocity balance gravitational acceleration, frictional resistance, air drag. Higher md values imply greater momentum less deceleration drag.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/runoutSim.html","id":"applicability","dir":"Reference","previous_headings":"","what":"Applicability","title":"Simulate Runout Paths Using Random Walk and PCM Physics — runoutSim","text":"model can applied variety gravity-driven mass movements debris flows, snow avalanches, similar phenomena. random walk approach, combined PCM velocity model, makes highly versatile simulating different types runout based underlying physical principles mass movement.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/runoutSim.html","id":"connectivity","dir":"Reference","previous_headings":"","what":"Connectivity","title":"Simulate Runout Paths Using Random Walk and PCM Physics — runoutSim","text":"source_connect = TRUE, simulated paths checked intersection connectivity feature raster. enables downstream analysis connectivity probability (connToRaster()), flow velocity surfaces (velocityToRaster()).","code":""},{"path":[]},{"path":[]},{"path":"https://jngtz.github.io/runoutSIM/reference/sourceConnect.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Probability of Source-Feature Connectivity — sourceConnect","title":"Estimate Probability of Source-Feature Connectivity — sourceConnect","text":"Calculates proportion simulated paths (e.g., random walk runout simulations) intersect binary connectivity feature mask.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/sourceConnect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Probability of Source-Feature Connectivity — sourceConnect","text":"","code":"sourceConnect(sim_paths, feature_mask, trials = NULL)"},{"path":"https://jngtz.github.io/runoutSIM/reference/sourceConnect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Probability of Source-Feature Connectivity — sourceConnect","text":"sim_paths list matrices, containing (row, col) indices cells visited simulation path. feature_mask binary matrix indicating presence (1) connectivity feature (makeConnFeature()). trials Optional integer specifying many simulation paths consider. Defaults paths.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/sourceConnect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Probability of Source-Feature Connectivity — sourceConnect","text":"numeric value 0 1 indicating estimated probability connection.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/sourceConnect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Probability of Source-Feature Connectivity — sourceConnect","text":"","code":"if (FALSE) { # \\dontrun{ p_connect <- sourceConnect(sim_paths, feature_mask, trials = 1000) } # }"},{"path":"https://jngtz.github.io/runoutSIM/reference/velocityToRaster.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Runout Velocities to Raster — velocityToRaster","title":"Convert Runout Velocities to Raster — velocityToRaster","text":"Aggregates maximum velocities runout simulation paths raster, using specified summary method multiple simulations overlap.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/velocityToRaster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Runout Velocities to Raster — velocityToRaster","text":"","code":"velocityToRaster(x, dem, method = \"max\")"},{"path":"https://jngtz.github.io/runoutSIM/reference/velocityToRaster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Runout Velocities to Raster — velocityToRaster","text":"x list simulation outputs containing cell_max_vel cell_trav_freq. dem SpatRaster (DEM) used reference. method Summary function apply across overlapping simulations (e.g., \"max\", \"mean\").","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/velocityToRaster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Runout Velocities to Raster — velocityToRaster","text":"SpatRaster cell values representing maximum velocity (m/s).","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/velocityToRaster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Runout Velocities to Raster — velocityToRaster","text":"","code":"if (FALSE) { # \\dontrun{ # Convert velocity results to a raster trav_vel <- velocityToRaster(sim_paths, dem) plot(trav_vel) } # }"},{"path":"https://jngtz.github.io/runoutSIM/reference/walksToRaster.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Random Walk Results to Raster — walksToRaster","title":"Convert Random Walk Results to Raster — walksToRaster","text":"Aggregates output runoutSim() raster showing often cell traversed runout simulations. Optionally weights walk supplied vector (e.g., probability initiation).","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/walksToRaster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Random Walk Results to Raster — walksToRaster","text":"","code":"walksToRaster(x, dem, method = \"freq\", weights = NULL)"},{"path":"https://jngtz.github.io/runoutSIM/reference/walksToRaster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Random Walk Results to Raster — walksToRaster","text":"x list runout simulation outputs (e.g., runoutSim()). dem SpatRaster object representing reference DEM. method Method combining overlaying runout paths: \"freq\" \"cdf_prob\" calculate traverse frequency cumulative distribution function probabilities simulations single source cell. \"max_cdf_prob\" \"avg_cdf_prob\" calculate maximum/average empirical probabilites CDF's applied walks invididual source cells. weights Optional numeric vector weights (length x) scale traverse frequencies.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/walksToRaster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Random Walk Results to Raster — walksToRaster","text":"SpatRaster cell values representing weighted unweighted traverse frequencies.","code":""},{"path":"https://jngtz.github.io/runoutSIM/reference/walksToRaster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Random Walk Results to Raster — walksToRaster","text":"","code":"if (FALSE) { # \\dontrun{ # Convert simulated paths to a raster of transition frequencies paths_raster <- walksToRaster(sim_paths, dem) plot(paths_raster) } # }"}]
